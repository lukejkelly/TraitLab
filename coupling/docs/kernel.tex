\documentclass[11pt,a4paper]{article}

% Setting up.
\usepackage[margin=1in]{geometry}
\usepackage{amsthm,amsmath,amsfonts,amssymb,mathtools}
\usepackage[authoryear,round]{natbib}
\usepackage{parskip}

\usepackage[sfdefault]{FiraSans}
\usepackage{eucal}
\usepackage{palatino}
\usepackage[T1]{fontenc}

\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{color,colortbl}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{subcaption}

\usepackage{graphicx}
\usepackage[colorlinks,citecolor=RoyalBlue,urlcolor=RoyalBlue,
            linkcolor=RoyalBlue,bookmarks=false]{hyperref}

\usepackage[framed]{matlab-prettifier}
\lstMakeShortInline"
\lstset{style=Matlab-editor,
        basicstyle=\mlttfamily,
        % escapechar=",
        mlshowsectionrules=true}

% Some macros
\newcommand{\edge}[2]{\langle#1, #2\rangle}
\newcommand{\pa}{\mathrm{pa}}
\newcommand{\sib}{\mathrm{s}}
\newcommand{\off}{\mathrm{o}}
\newcommand{\cla}{\mathrm{c}}

\newcommand{\Exp}[1]{\mathrm{Exp}(#1)}
% \newcommand{\Unif}[2]{\mathrm{U}[#1, #2]}
\DeclarePairedDelimiter\abs{\lvert}{\rvert}%

\DeclareMathOperator*{\Unif}{\mathrm{U}}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator{\supp}{supp}

\definecolor{myblue}{rgb}{0.25, 0.75, 1.00}
\definecolor{mygreen}{rgb}{0.75, 1.00, 0.00}
\definecolor{myred}{rgb}{1.00, 0.50, 0.50}
\definecolor{myorange}{rgb}{1.00 0.75 0.25}

\title{\vspace{-2.5cm} Coupled kernel in TraitLab}
\author{Luke Kelly}
% \date{December 2020}

\begin{document}

\maketitle
\tableofcontents

\section{Moves}

Table~\ref{tab:moves} lists the various types of moves and whether we are coupling them using common random numbers of maximal couplings. Some things to note:
\begin{itemize}
    \item Moves which use a single random variable to scale multiple parameters cannot be maximally coupled as the supports do not overlap except in special cases (one state was formed only by scaling the other state).
    \item Currently we are not worrying about the problem of missing data, catastrophes or offset leaves.
    \item We can integrate $ \lambda $ and $ \rho $ out analytically.
\end{itemize}

\begin{table}[ht]
    \centering
    \caption{Proposals are \colorbox{myblue!50}{common random number} and \colorbox{mygreen!50}{maximal} couplings.}
    \label{tab:moves}
    \begin{tabular}{@{}rll@{}}
        \toprule
        \# & Type & Main function \\ \midrule
        \rowcolor{mygreen!50}
        1 & Random walk on node time & "SchooseCoupledMaximal" \\
        \rowcolor{myblue!50}
        2 & Exchange edges (narrow)) & "Echoose" \\
        \rowcolor{myblue!50}
        3 & Exchange edges (wide) & "Echoose" \\
        \rowcolor{mygreen!50}
        4 & SPR (narrow) & "BchooseCoupledMaximal"  \\
        \rowcolor{mygreen!50}
        5 & SPR (wide) & "BchooseCoupledMaximal" \\
        \rowcolor{myblue!50}
        6 & Rescale tree & "Rscale"  \\
        \rowcolor{myblue!50}
        7 & Rescale subtree & "RscaleSubTree"  \\
        \rowcolor{mygreen!50}
        8 & Vary $ \mu $ & "maximalCouplingUniformScaling" \\
        % \rowcolor{gray!10}
        ... & \textcolor{black!50}{(Unused)} &   \\
        % \rowcolor{gray!10}
        % 10 &  &   \\
        \rowcolor{myblue!50}
        11 & Resample leaf times & "MarkovCoupledCommon"  \\
        \rowcolor{myblue!50}
        12 & Rescale top tree & "RscaleTopTree" \\
        \rowcolor{myblue!50}
        13 & Add catastrophe & "AddCat" \\
        \rowcolor{myblue!50}
        14 & Delete catastrophe & "DelCat" \\
        \rowcolor{mygreen!50}
        15 & Vary $ \rho $ &  "maximalCouplingUniformScaling" \\
        \rowcolor{mygreen!50}
        16 & Vary $ \kappa $ & "maximalCouplingUniformScaling" \\
        \rowcolor{mygreen!50}
        17 & Vary $ \lambda $ & "maximalCouplingUniformScaling" \\
        \rowcolor{myblue!50}
        18 & Move catastrophe & "MoveCat" \\
        \rowcolor{mygreen!50}
        19 & Vary one $ \xi $ & "maximalCouplingUniformScaling" \\
        \rowcolor{myblue!50}
        20 & Vary all $ \xi $s & "MarkovCoupledCommon"  \\
        \rowcolor{mygreen!50}
        21 & Vary $ \beta $ & "maximalCouplingUniformScaling" \\
        \bottomrule
    \end{tabular}
\end{table}


%%
\section{Code structure}

Enter via "batchTraitLabCoupled" which calls "runmcmcCoupled". Both are essentially duplicates of "batchTraitLab" and "runmcmc" where I have inserted pieces to accommodate the coupling. (I need to tidy up "runmcmc" to remove the references to "state" and just call the state returned by "fullsetup" "state_x".)

\lstinputlisting[title = {Snippet of runmcmcCoupled setting up},linerange={41-59}]{../runmcmcCoupled.m}

Working backwards from the intuition that we would ideally like to couple a chain started at the prior with another started at the posterior, we do the initialisation in two stages:
\begin{enumerate}
    \item Build the initial states $ X_0 $ and $ Y_0 $.
    \begin{itemize}
        \item Currently we are starting from a standard random initialisation in TraitLab.
        \item Rather than worry whether "InitState" and other set-up functions return a draw from the prior, I'm just setting $ X_0 $ and $ Y_0 $ to the same initial state then advancing both by $ 10^4 $ marginal draws from the prior.
        \item "MarkovPrior" is identical to "Markov" but we don't evaluate the likelihood to make the accept/reject decision, only for the terminal state returned by the function.
    \end{itemize}
    \item Advance the $ X $ chain by the desired number of lags through calls to the marginal kernel, "Markov".
    \begin{itemize}
        \item \citet{jacob20} use $ l = 1 $ lags while \citet{biswas19} advocate more.
        \item We are using "mcmc.subsample" lags as from my reading of \citet{biswas19} that was the highest resolution we could use for the unbiased estimator \citep[Appendix~A.1]{biswas19}.
    \end{itemize}
\end{enumerate}
My understanding of the number of lags and setting the initial state was that it would reduce the variance of the unbiased estimator, but it was something I'd been meaning to talk to you about when I had the code up and running.

%%
\section{Coupled transition kernels}

The main loop of "runmcmcCoupled" then calls "MarkovCoupled" which selects a move "MV" and samples the $ \Unif[0, 1] $ random variable to use in the MH accept/reject stage, then directs the chains to jointly sample proposals from either from common random number or maximal coupling kernels depending on the move type.

\lstinputlisting[title = {Snippet of runmcmcCoupled main loop},linerange={85-85,97-98}]{../runmcmcCoupled.m}

(The "ignoreearlywarn" flag has been in "TraitLab" since before my time, I think it means improper states are ignored initially.)

We do "housekeeping" on the states before every move. We look at which subtrees are common across "state_x.tree" and "state_y.tree" then relabels the subtree roots in "y" to match "x"; finally, it updates the state-level variables. Then "superHousekeeping" updates the "sibling" information for subtree roots and "child" information for parents, if possible (this will be merged with "housekeeping" once I write the appropriate unit tests). The MRCAs of the leaves in a clade will always have the same indices after housekeeping

\lstinputlisting[title = {Snippet of MarkovCoupled},linerange={21-43,47-57}]{../MarkovCoupled.m}

Let's define some notation. Let $ s $ denote a tree on leaves $ L $, with ancestral nodes $ A $, root $ R $, all taking labels in $ V = L \cup A \cup R = [2 \abs{L} - 1] = \{1, 2, \dotsc, 2 \abs{L} - 1\} $, and an Adam node $ 2 \abs{L} $. For $ i \in V $, let $ \pa(i) $ denote its parent and $ \pa^2(i) $ its grandparent, $ \sib(i) $ its sibling, and $ \off(i) $ its offspring, if they exist. Let $ t_i $ denote the time of node $ i $ and $ \edge{\pa(i)}{i} $ the edge into $ i $ from its parent. Let $ \cla(i) $ denote the set of clades constraining $ i $. We denote $ \Exp{\theta; t} $ an exponential random variable with rate $ \theta $ conditioned to to be greater than $ t $.

For each coupled proposal $ j \in \text{Table~\ref{tab:moves}} $, we sample
\[
(s^{(x)}, s^{(y)}) \rightarrow (s^{(x)}{'}, s^{(y)}{'}) \sim \Gamma\big(K_j(s^{(x)}, \cdot), K_j(s^{(y)}, \cdot)\big),
\]
we return the same (log-)proposal ratios as in the corresponding marginal moves $ j $ to the same states.


%%
\subsection{Common random number couplings}

"MarkovCoupledCommon" is a straightforward modification of "Markov" to take the MH acceptance probability as an argument. As we can see in "MarkovCoupled", above, the RNG is initialised to the same state before each call to "MarkovCoupledCommon". We then re-seed the RNG afterwards in case uncoupled chains made a different number of calls to the RNG; for example, when a move fails in one chain.

%%
\subsection{Maximal couplings}

"MarkovCoupledMaximal" has a similar structure to "MarkovCoupledCommon" but with marginal updates replaced by joint ones.

%%
\subsubsection{Rescaling node times}

\lstinputlisting[title = {Snippet of MarkovCoupledMaximal},linerange={15-21}]{../MarkovCoupledMaximal.m}

The marginal move "Schoose" operates on a tree "s" as follows: sample $ i \sim \mathrm{Unif}{A \cup R} $ and let $ t_j = \max_{j' \in \off(i)} t_{j'} $,
\begin{itemize}
    \item "if" $ i = R $,
    \[
        t_i' \sim \Unif\left[\frac{(t_i + t_j)}{2}, 2(t_i - t_j)\right]
            = t_i + \Unif\left[-\frac{(t_i - t_j)}{2}, t_i - t_j\right]
    \]
    \item "else" $ t_i' \sim \Unif[t_j, t_{\pa(i)}] $.
\end{itemize}
For coupled chains $ x $ and $ y $, both trees have the same root index through housekeeping ($ R^{(x)} =  R^{(y)} $) so we just need to couple sampling new node times and return the same ratios of proposal distributions as in "Schoose".

\lstinputlisting[title = {Snippet of SchooseCoupledMaximal},linerange={6-25}]{../SchooseCoupledMaximal.m}

%%
\subsubsection{SPR moves}

For a node $ i $, we reattach its parent $ \pa(i) $ to $ \edge{k}{j} $, where
\begin{itemize}
    \item "if mt == NARROW", then $ \edge{k}{j} = \pa^2(i) $ and $ j = \sib(\pa(i)) $
    \item "else" $ \edge{k}{j} $ is chosen uniformly(-ish) across the tree.
\end{itemize}

\lstinputlisting[title = {Snippet of MarkovCoupledMaximal},linerange={35-37}]{../MarkovCoupledMaximal.m}

In all cases, $ i \sim \Unif\{A\} $. For a "NARROW" move in "Bchoose",
\begin{enumerate}
    \item "if" $ \pa(i) = R $, the move fails (as $ \sib(\pa(i)) = \emptyset $) and the function exits\footnote{We could account for this in step 1 so $ 2 / \abs{A} $ of the narrow moves fail unneccessarily.}
    \item "else" $ k = \pa^2(i) $ and $ j = \sib(\pa(i)) $
    \item $ t_{\pa(i)}' \sim \Unif[t_i \vee t_j, t_k] $.
\end{enumerate}
For a "WIDE" move in "Bchoose", we need to account for clade constraints.
\begin{enumerate}
    \item Get a set $ r $ of possible destination edges indexed by the offspring node
    \begin{itemize}
        \item "if" clades then $ r = \{l \in V: \cla(\pa(l)) = \cla(\pa(i)) \subseteq \cla(l)\} $; that is, the set of nodes whose parent is as constrained as $ \pa(i) $ (this is much simpler than what's in the code)
        \item "else" we let "r = V" (this includes the edge between Adam and $ R $ whereas the move when there are clades does not even if the constraint there is on a leaf).
    \end{itemize}
    \item Select a destination edge
    \begin{itemize}
        \item "if" $ \abs{r} \leq 4 $, then the move fails and the function exits
        \item "else" $ \edge{k}{j} \sim \Unif\{l \in r : t_{\pa(r)} > t_i, i \neq r, i \neq \pa(r)\} $, the set of edges whose parent is older than $ i $ and don't connect to it
    \end{itemize}
    \item "if" $ \pa(i) = k $ or $ \pa(i) = j $ then the function fails and exits\footnote{This is another point where we could have possibly have selected a valid destination but chose this one first}
    \item Propose a new time for $ \pa(i) $
    \begin{itemize}
        \item "if j == R", then $ t_{\pa(i)}' = t_j + \Exp{\theta} $
        \item "else" same as "NARROW" move with a different ratio of proposal distributions if "k == R"
    \end{itemize}
\end{enumerate}
With "BchooseCoupledMaximal", we need to account for all combinations of failures, move types and destination edge locations.
\begin{enumerate}
    \item Select the destination edge. Either or both chains can fail at this stage.
    \begin{itemize}
        \item "if mt == NARROW", then $ \edge{k^{(x)}}{j^{(x)}} $ may or may not be the same as $ \edge{k^{(y)}}{j^{(y)}} $; as in "Bchoose" this move for $ x $ if $ \pa(i^{(x)}) = R^{(x)} $, and likewise for $ y $
        \item "if mt == WIDE" then $ i $ is in the same clade group in both $ x $ and $ y $ through housekeeping so $ r = r^{(x)} = r^{(y)} $ and we sample destination edge $ \edge{\pa(j)}{j)} $ uniformly from $ r $
        \begin{itemize}
            \item In "Bchoose", we repeatedly draw $ j \sim \Unif(r) $ and set $ k = \pa(j) $ until $ t_k > t_i $ and $ i \neq j \neq k $
            \item We couple this move through a similar process to common random numbers. Initially $ r $ is sorted so we shuffle it before passing it to "BchooseCoupledMaximal.getWideDestination" which is similar to "Bchoose" but goes through the shuffled $ r $ in order looking for valid destinations
            \item As each chain moves through the candidate destination set in the same order, then if an edge is valid in both and is considered the both chains will select it. In practice, an edge may be invalid for one state as time ranges do not overlap so the move can fail in one state and succeed in another
            \item I do not think this requires an extra Jacobian term as it's equivalent to the marginal move and we're doing it using common random numbers so do not need to evaluate the probability mass function
        \end{itemize}
    \end{itemize}
    \item Propose node times (I discuss the actual sampling mechanisms below)
    \begin{itemize}
        \item "if" neither chain has failed, sample from a coupling
        \begin{itemize}
            \item "if" $ j^{(x)} = j^{(y)} = R $, then
            \[
                (t_{\pa(i)}^{(x)}, t_{\pa(i)}^{(y)}) \sim \Gamma\big(\Exp{\theta; t_j^{(x)}}, \Exp{\theta; t_j^{(y)}}\big),
            \]
            both new ages Exponential above respective current root.
            \item "elseif" $ j^{(x)} = R $, then draw new age in x from Shifted Exponential and y from Uniform,
            \[
                (t_{\pa(i)}^{(x)}, t_{\pa(i)}^{(y)}) \sim \Gamma\big(\Exp{\theta; t_j^{(x)}}, \Unif[t_i^{(y)} \vee t_j^{(y)}, t_k^{(y)}]\big)
            \]
            \item "elseif" $ j^{(y)} = R $, then draw new age in x from Uniform and y from Shifted Exponential
            \item "else", both new ages uniform,
            \[
                (t_{\pa(i)}^{(x)}, t_{\pa(i)}^{(y)}) \sim \Gamma\big(\Unif[t_i^{(x)} \vee t_j^{(x)}, t_k^{(x)}], \Unif[t_i^{(y)} \vee t_j^{(y)}, t_k^{(y)}]\big),
            \]
            ratio of proposals depends on whether $ \pa(i) $ is the root or not.
        \end{itemize}
        \item "elseif" one chain has failed then draw $ t_{\pa(i)}' $ in the other from the marginal sampler (same as "Bchoose")
    \end{itemize}
\end{enumerate}

%%
\subsubsection{Edge exchange}

As with SPR moves, these can be "WIDE" or "NARROW". These moves are entirely discrete and nodes are sampled uniformly so our common random number coupling should be identical to a maximal coupling of the marginal "Echoose" function.

The "NARROW" move was previously causing chains to decouple as it relied on sibling information which had not been included in "housekeeping".

%%
\subsubsection{Moves on scalar parameters}

These are covered in the section below.


%%
\section{Sampling couplings}

We use two approaches to sample $ X \sim p $ and $ Y \sim q $ from a maximal coupling.
\begin{itemize}
    \item Sample from overlap or sample independently
    \begin{enumerate}
        \item With probability $ [p \wedge q] = \int (p \wedge q)(\mathrm{d} x) $,
        \[
            X \leftarrow Y \sim \frac{p \wedge q}{[p \wedge q]}
        \]
        \item Otherwise
        \[
            X \sim \frac{p - p \wedge q}{1 - [p \wedge q]}
            \quad \text{and} \quad
            Y \sim \frac{q - p \wedge q}{1 - [p \wedge q]}.
        \]
    \end{enumerate}
    \item Sample $ X $ and do rejection sampling for $ Y $ (described in code below)
\end{itemize}

%%
\subsection{Two Shifted Exponential distributions}

We have $ p = \Exp{\theta; a_p} $ and $ q = \Exp{\theta; a_q} $.

With probability $ [p \wedge q] = \exp(-\theta \abs{a_p - a_q}) $, we couple and
\[
X \leftarrow Y \sim \Exp{\theta; a_p \vee a_q}.
\]
Otherwise, sample independently. Let $ \Exp{\theta; c, d} $ denote an Exponential($ \theta $) distribution truncated to $ [c, d) $. Now, if $ a_p < a_q $, then
\begin{alignat*}{3}
    X &\sim \Exp{\theta; a_p, a_q}
        &=& a_p - \theta^{-1} \log[1 - U_x (1 - e^{-\theta (a_q - a_p)})], \\
    Y &\sim \Exp{\theta; a_q}
        &=& a_q - \theta^{-1} \log(U_y),
\end{alignat*}
where $ U_x, U_y \sim \Unif[0, 1] $. If $ a_q < a_p $ then we change the sampling distributions appropriately.

%%
\subsection{Uniform and Shifted Exponential}

Suppose $ X \sim p = \Unif[a, b] $ and $ Y \sim q = \Exp{\theta; c} $. In this setting we use a "while" loop to sample from the coupling using the recipe in \citet{jacob20}.

\lstinputlisting[title = {Snippet of maximalCouplingLog},linerange={4-15}]{../maximalCouplingLog.m}

%%
\subsection{Uniform scaling moves}

These are for coupling proposals such as $ \mu' = \mu \times \Unif[\delta^{-1}, \delta] $.

\lstinputlisting[title = {Snippet of maximalCouplingUniformScaling}]{../maximalCouplingUniformScaling.m}

%%
\subsection{Uniform and Uniform}

Same as the Uniform and Shifted Exponential so we use the same "while" loop to draw $ Y $ but with appropriate sampling and density functions.

I did write code to remove the "while" loop and just do inversion sampling on piecewise CDFs, but accounting for the different cases meant a lot of code so I haven't tested it to the point that I'd include in in the algorithm.

%%
\bibliographystyle{plainnat}%
\bibliography{kernel}%

\end{document}
